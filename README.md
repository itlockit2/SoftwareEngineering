CHAPTER 9. 테스팅(Testing)
=============
테스팅은 개발하는 동안 발견되지 않은 오류를 찾아내는 작업이다.
소프트웨어에서는 테스트케이스를 주어 예상한대로 실행되는지 확인한다.
## 9.1 테스팅 기초
테스트란 "시스템이 정해진 요구를 만족하는지, 예상과 실제결과가 어떤 차이를 보여주는지
소등 또는 자동방법을 동원하여 검사하고 평가하는 일련의 과정"을 뜻한다.
### 9.1.1. 오류, 결함, 고장
 - 오류(Error) : 개발자의 실수로 잘못된 결과를 생성하는 모든 작업들
 - 결함(Default, Fault, Bug) : 소프트웨어 코드로 인한 에러 발생
 - 고장(Failure) : 결함으로 인한 소프트웨어의 실행결과가 예상과 다른것
### 9.1.2. 테스팅 원리
  1. 오류를 발견하기 위해 프로그램을 실행
  2. 완벽한 테스팅은 불가능 하다.
  3. 테스팅은 구현과 관계없는 독립된 팀에 의하여 수행되어야 한다.
### 9.1.3. 테스트 작업과정
  1. 목표설정 : 무엇을 점검 할 것인가?
  2. 방법결정 : 테스트 방법 설정(검사, 증명, 블랙박스 테스팅, 화이트 테스팅, 자동화 도구)
  3. 테스트케이스 개발
  4. 테스팅의 올바른 결과 작성 : 테스트 케이스 실행이 통과되었는지 실패하였는지 판단하기 위한 기준을 테스트 오라클(Test Oracle)이라고 한다.
  5. 테스트 케이스 실행 : 일부 기능만 시험하기 위해 소프트웨어에 변경을 가하는 경우를 테스트 하니스(Test Harness)라고 한다.
### 테스트 작업 단계
  - 단위 테스팅(Unit Testing) : 모듈을 구현한 프로그래머가 각 모듈이 정확하고 제대로 기능하는지 테스트하는 것
  - 통합테스팅(Integration Testing) : 전체시스템을 이루는 모듈들이 서로 잘 수행되어 시스템이 요구된 기능을 잘 구현하는지 테스트 하는 것
  - 시스템 테스팅(System Testing) : 시스템이 사용될 준비가 완료 되었는지 테스팅 하는것
  - 인수테스팅(Acception Testing) : 사용자, 발주자가 직접 테스팅 하는 것
  - 리그레션 테스팅(Regression Testing) : 시스템이 설치되고 유지보수 단계에서 이루어지는 테스팅
  - 전수 테스팅(Exhaust Testing) : 테스트 케이스가 모든 가능한 에러를 다 검출 할수 있는 이상적인 집합(비현실적이고 불가능하다)
  ![Alt text](/1.jpg)
### 9.1.4.테스트 케이스(Test Case)
테스트 케이스에는 테스크 대상별로 테스트조건, 테스트데이터 예상결과가 일반적으로 포함되어있다.
  ![Alt text](/2.jpg)
## 9.2 블랙박스 테스팅(Blockbox Testing)
시스템이나 모듈 요구 명세서를 토대로 기능테스팅(Functional Testing)을 하는것으로
명세서를 기반으로 하기 때문에 Spec-Based Test 라고도 한다. 
또한 코드 내용을 고려하지 않기 때문에 Black Box Test라고 하며
입력에 따른 올바른 행동을 검사하므로 행동적 테스트(Behavioral Test)라고 한다.
### 9.2.1. 동치 클래스 분해(Equivalence Class Partitioning)
전수 테스팅을 하는것은 비효율적이므로 입력값의 영역을 동치클래스로 나누고
프로그램이 어떤 값에 대하여 올바로 실행된다면 그 값이 속하는 클래스에 있는
모든 값에 대하여 올바로 실행될것이라고 간주한다.
### 9.2.2. 경계값 분석(Boundary value analysis)
동치클래스의 경계에 있는 값에서 이상이 생기는지 분석하는 단계
ex) 정수의 범위가 MIN에서 MAX라고 할때
MIN-1, MIN, MIN+1, MAX-1, MAX, MAX+1, Normal value
즉 변수의 개수에 따라 6N+1개의 테스트케이스를 가진다.
### 9.2.3. 원인과 결과 그래프(Cause-Effect Graph)
앞의 두 방법은 각 입력에 대해 독립적으로 테스트케이스를 만들었지만
이번 방법은 여러 입력들의 조합을 고려하여 테스트케이스를 만든다.
먼저 테스트 하려는 시스템의 원인과 결과를 파악한다. 그 후 각 결과에 대하여 이런 결과를
낳게 하는 원인과 어떤 조건이 조합되어야 하는지 찾아낸다.
 - Ex) 입출금 원인 결과 그래프
 #### 원인
 1. 명령어가 입금
 2. 명령어가 출금
 3. 계정 번호가 정상
 4. 트랜젝션 금액이 정상
 #### 결과
 1. '명령어 오류'라고 인쇄
 2. '계정 번호 오류'라고 인쇄
 3. '출금액 오류'라고 인쇄
 4. 트랜젝션 금액 입금
 5. 트랜젝션 금액 
 
   ![Alt text](/3.jpg)
   ![Alt text](/4.jpg)
## 9.3 화이트박스 테스팅(WhiteBox Testing)
블랙박스와는 다르게 모듈안의 작용을 자세히 관찰하는 테스팅 방법이다.
논리적인 구조를 체계적으로 점검한다.
### 9.3.1 논리 흐름의 표현
화이트박스 테스팅을 더 자세히 이해하기 위해 논리흐름도(Logic-Flow-Diagram)을 이용한다.
   ![Alt text](/5.jpg)
   ![Alt text](/6.jpg)
### 9.3.2. 기본경로 테스팅(Basis Path Testing)
화이트박스 테스팅의 기본개념은 기본경로(Basis Path)라 불리는 독립적인 논리 흐름을 검사하는 테스트 케이스를 이용한다.
기본경로란 흐름 그래프의 시작 노드에서 종료노드 까지의 서로 독립된 경로로 싸이클은 최대 한번만 허용하는 경로이다.
### 9.3.3. 싸이클로매틱 복잡도(Cyclomatic complexity)
기본경로의 수는 싸이클로매틱 복잡도를 이용하여 구할 수 있다.
1. 폐쇄 영역의 수 + 1
2. 노드와 간선의 수
3. 단일 조건의 수 +1
#### 기본 경로 예제
![Alt text](/7.jpg)
![Alt text](/8.jpg)

### 9.3.4. 테스트 커버리지
#### Statement coverage(= Node coverage)
테스트 케이스에 의해 실행된 문장(Statement) = 노드(Node)의 비율을 뜻한다.
![Alt text](/9.jpg)
#### Decision coverage(= Branch coverage)
Decision : 조건식을 참 또는 거짓을 판단함
테스트 케이스에 의해 실행된 분기의 비율을 뜻한다.
#### Condition Coverage
Condition : 가장 작은 단위의 조건
테스트 케이스에 있는 조건문에 있는 원자조건의 TRUE/FALSE의 비율을 뜻한다.
이해가 잘 안간다면 밑에 있는 그림을 참조할것.
![Alt text](/10.jpg)
#### Condition/Decision Coverage
Condition Coverage와 Decision Coverage 둘다를 만족하는 테스트케이스들의 집합
####  Multiple-Condition coverage
각 조건(Condition)의 모든 조합을 테스트하는 Test suite
하지만 이경우 모든 조합을 테스트하므로 테스트케이스의 수가 2^{# of 원자 조건(atomic conditions)}가 된다.
#### Modified Condition Decision Coverage(MC/DC)
Multiple-Condition coverage와 동일한 조건/결정 범위이지만
TC수를 좀더 줄이기 위해 고안된 Coverage이다.
결과가 다르고 단 하나의 조건의 값만 다른 것을 MC/DC 쌍이라 부른다.
* ex) if(A && B && C){...}
* TC1: A,B,C = (T,T,T) : outcome=T
* TC2: A,B,C = (T,T,F) : outcome=F
조건 C만 달라졋는데 결과값이 달라졌다 이럴때 TC1과 TC2를 MC/DC 쌍이라 부른다.
![Alt text](/11.jpg)

## 9.4 객체지향 테스팅(Object-Oriented Testing)
앞에서 설명한 Black Box와 White Box는 클래스안에 있는 메소드에 적용할 수 있는 테스트 방식이다.
### 9.4.1 사용 사례 기반 테스팅
유즈케이스로 부터 테스트 케이스를 추출하는 방법이다.
1. 액터의 입력과 액션을 파악한다.
2. 입력 값을 결정한다.
  * 정상적인 값
  * 비정상적인 값
  * 예외적인 값
3. 테스트 케이스를 생성한다.
![Alt text](/12.jpg)
4. 실제적인 테스트 케이스를 생성한다.
![Alt text](/13.jpg)
### 9.4.2 상태 기반 테스팅
시스템의 상태 모델을 구축한 후에 테스팅하는 방법으로 
상태다이어 그램을 토대로 테스팅을 시행한다.
 * 모든 트랜지션: 테스트 케이스 집합이 상태 그래프의 모든 트랜지션을 점검한다.
 * 모든 트랜지션 쌍 : 테스트 케이스 집합이 모든 이웃 트랜지션의 쌍을 점검한다. 이웃 트랜지션이란 어떤 상태에 들어오는 유입 트랜지션과 방출 트랜지션을 의미한다. 모든 트랜지션보다 더 엄격하게 검사가 된다.
   * ex) 어떤 상태가 t1,t2 두개의 유입 트랜지션과 두 개의 방출 트랜지션 t3, t4가 있다면 t1;t3, t2;t4도 만족하는지 점검하는 것이다.
 * 트랜지션 트리 : 단순 경로를 만족시키는 기준으로 단순 경로란 시작 상태에서 출발하여 그래프에 있는 다른 상태로 중복되지 않고 방문 될 수 있는 경로를 말한다.
## 9.5 통합테스팅
시스템을 구성하는 모듈의 인터페이스와 결합을 테스트 하려는 것이다.
* Driver : 테스트를 하기위해 임시로 만들어낸 테스트장치 테스트 하니스와 유사하다.
* Stub : 특정 시스템의 기능이 개발이 되지 않았음에도 테스트를 하기위해 임시로 만들어낸 컴포넌트
* 만약 DVD 플레이어의 컨트롤러를 만들었는데 실제 버튼이 있는 판넬과 DVD를 돌리는 장치부분이 완성되지 않는 상태에서
테스트를 진행한다 가정하자.
  * 실제 버튼이 없는데 버튼을 눌렀을때의 시스템 로직을 테스트 하고 싶을때, 버튼이 눌러진것 처럼 가상의 프로그램을 만든것을 드라이버라고 한다.
  * 아때 DVD를 돌리는 장치도 완성되지 않았으므로 임시로 장치를 구현해 명령을 받고 성공 및 실패값에 대해 리턴해주는 프로그램을 스텁이라고 한다.
### 9.5.1 빅뱅 통합
모든 모듈을 모아 통합하여 테스트 하는 방법으로 시스템을 이루는 모든 모듈들이 한꺼번에 테스트되므로 오류의 위치와 원인을 찾아내기가 어렵다는 단점이 있다.
### 9.5.2 하향식 통합
시스템의 구조도의 위층에 있는 모듈부터 아래층의 모듈로 내려오면서 통합되는 방법이다.
 * 장점
   * 상위층의 중요한 인터페이스를 조기에 시험 할 수 있다.
   * 스텁의 사용으로 시스템의 모습을 사용자에게 일찍 보여줄 수 있다.
 * 단점
   * 입출력을 수행하는 모듈이 대부분 최하위에 존재하므로 어려움이 있다.
   * 중요한 기능을 수행하는 최하위층 모듈은 충분한 시험을 할 수 없다.
### 9.5.3 상향식 통합
최하위 모듈을 먼저 통합하여 시험하는 방법이다.
* 장점
  * 오류 발견이 쉽고 하위층에 중요한 기능을 많이 테스트하게 된다.
* 단점
  * 시스템의 모든 계층을 마지막에 가서야 확인 할 수있어서 상위층의 중요한 인터페이스를 마지막에 확인한다는 점과 개발 의뢰자에게 시스템을 사용해 볼 수 있는 기회를 제공하지 못한다는 단점이 있다.
### 9.5.4 연쇄식 통합
특정 기능을 수행하는 모듈의 최소단위(Thread) 즉 입력, 출력, 어느 정도의 기본 기능을 수행하는 모듈부터 통합 테스트를 시작한다.

## 9.6 시스템 및 인수테스트
### 9.6.1 기능테스트
### 9.6.2 성능테스트
### 9.6.3 사용자 인터페이스 테스트
### 9.6.4 인수테스트

## 9.7 테스트도구
### 9.7.1 코드 분석 도구
* 정적 분석 도구
  * 코드 분석 도구
  * 구조 검사 도구
  * 데이터 분석 도구
  * 순서 검사 도구
### 9.7.2 테스트 케이스 생성 도구
1. 자료 흐름도
2. 기능 테스트 방법
3. 입력 도메인 분석
4. 랜덤 테스트
### 9.7.3. 테스트 케이스 실행 도구
1. 캡쳐 및 리플레이
테스트 계획에 표시된 테스트 데이터를 자동으로 입력하고 실행 과정에 발생하는 화면이나 인쇄되는 결과를 
2. 스텁과 드라이
통합테스트를 위해서 자동으로 스텁과 드라이버를 생성한다.
3. 자동 테스트 환경
테스트 수행 도구들이 테스트 환경으로 통합되어 제공 되어 테스트 작업을 자동화하도록 제공된다.
### 9.7.4. 단위 테스트 도구
JUnit과 같은 프레임워크로 테스트 대상 클래스의 객체를 만들고
메소드를 호출하여 결과를 예상하는 값과 비교하는 패턴으로 테스트한다.
